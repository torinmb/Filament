<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:fb="http://ogp.me/ns/fb#"
      lang="en">
	<head>
		<title>Filament Music Visualizer</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<meta property="og:image" content="Filament.jpg" />
		<link rel="stylesheet" href="main.css" />
		<script>
		  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

		  ga('create', 'UA-92983687-1', 'auto');
		  ga('send', 'pageview');

		</script>
	</head>
	<body>

		<div id="container"></div>
		<!-- <div id="info"><a href="http://uwc.graphics" target="_blank">CGPP</a> FBM Triangle Shredder</div> -->
		<div id="progressBar" class="floatCenter">
		  <div id="bar"></div>
		</div>
		<script src="js/MobileAndTabletCheck.js"></script>
		<script src="js/three.js"></script>
		<script src="js/dat.gui.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/stats.min.js"></script>
	    <script src="js/OrbitControls.js"></script>
		<script src="js/TessellateModifier.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/ColorTracker.js"></script>
		<script src="js/Tween.js"></script>
		<script src="js/KeyFrames.js"></script>

		<script id="vertexShader" type="x-shader/x-vertex" src=>

			precision mediump float;
			precision mediump int;

			uniform mat4 modelViewMatrix; // optional
			uniform mat4 projectionMatrix; // optional
			uniform float time;
			uniform float audio[16];
			uniform float sensitivity;
			uniform float amplitude;
			uniform float scale;
			uniform float sinScale;
			uniform float noiseIterations; 
			uniform float triangleSize; 
			uniform float abMix;
			uniform float highFrequencyMix;
			uniform vec2 mouse;


			attribute vec3 position;
			attribute vec3 normal;
			attribute vec3 positionB;
			attribute vec3 normalB;
			attribute vec4 color;

			varying vec3 vPosition;
			varying vec3 vNormal;
			varying vec4 vColor;


			/// NOISE CODE 
			//  noise from https://www.shadertoy.com/view/XsX3zB
		    /* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */
			vec3 random3(vec3 c) {
				float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
				vec3 r;
				r.z = fract(512.0*j);
				j *= .125;
				r.x = fract(512.0*j);
				j *= .125;
				r.y = fract(512.0*j);
				return r-0.5;
			}

		    /* skew constants for 3d simplex functions */
		    const float F3 =  0.3333333;
		    const float G3 =  0.1666667;
		    /* 3d simplex noise */
		    float simplex3d(vec3 p) {
				/* 1. find current tetrahedron T and it's four vertices */
				/* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */
				/* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/
				/* calculate s and x */
				vec3 s = floor(p + dot(p, vec3(F3)));
				vec3 x = p - s + dot(s, vec3(G3));
				/* calculate i1 and i2 */
				vec3 e = step(vec3(0.0), x - x.yzx);
				vec3 i1 = e*(1.0 - e.zxy);
				vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				/* x1, x2, x3 */
				vec3 x1 = x - i1 + G3;
				vec3 x2 = x - i2 + 2.0*G3;
				vec3 x3 = x - 1.0 + 3.0*G3;
				/* 2. find four surflets and store them in d */
				vec4 w, d;
				/* calculate surflet weights */
				w.x = dot(x, x);
				w.y = dot(x1, x1);
				w.z = dot(x2, x2);
				w.w = dot(x3, x3);
				/* w fades from 0.6 at the center of the surflet to 0.0 at the margin */
				w = max(0.6 - w, 0.0);
				/* calculate surflet components */
				d.x = dot(random3(s), x);
				d.y = dot(random3(s + i1), x1);
				d.z = dot(random3(s + i2), x2);
				d.w = dot(random3(s + 1.0), x3);
				/* multiply d by w^4 */
				w *= w;
				w *= w;
				d *= w;
				/* 3. return the sum of the four surflets */
				return dot(d, vec4(52.0)) + 0.5;
		    }

		    float fractalNoise(vec3 p)
		    {
		        float f = 0.0;
		        float a = 0.5;
		        p = p + vec3(0.0, 0.5, 0.0) * time * 5.02;
		        p = p * scale;
		        //mat3 rot = mat3(cos(simplex3d(p).x*-0.020), sin(simplex3d(p).z*0.5), sin(simplex3d(p).z*0.02),
                    			// -sin(simplex3d(p).x*0.5), cos(simplex3d(p).y*0.50), sin(simplex3d(p).z*0.05),
                    			// -cos(simplex3d(p).x*0.02), sin(simplex3d(p).y*0.02), sin(simplex3d(p).z*-0.02));
		        
		        
		        for (float i = 0.0; i < 8.0; i++ ) {
		        	if( i > noiseIterations) {
		        		break;
		        	}
		        	

		            f += a * simplex3d(p) * sqrt(sensitivity) * (pow( 0.003906 * audio[int(i)], sensitivity));
		            p *= 2.0 ;
		            a *= highFrequencyMix;
		        }
		        return f;
		    }
		    
	  		/// END NOISE CODE

		void main()	{

			vPosition = mix(position, positionB, abMix);
			vColor = color;

	        vec3 p = mix(position, positionB, abMix);
	        vec3 noise = vec3(fractalNoise(p.xyz),fractalNoise(p.zyx),fractalNoise(p.yzx))-0.5;
	        vNormal = mix(normal, normalB, abMix) + amplitude * sin( noise * sinScale );
	        p = (p) + amplitude * sin( noise * sinScale);

	        //float dist = distance(p, vec3(mouse * 300.0-300.0, 0.0));
	        // p.x += ;
	        //p = mix(p, vec3(mouse * 300.0-300.0, 0.0), 1.0/dist);
	        //p.z += 20000.0 / (1.0+dist);

			gl_Position = projectionMatrix * modelViewMatrix * vec4( p, 1.0 );
			gl_PointSize = min((audio[2] * audio[4] + audio[5] + audio[6] * audio[7] * 3.0)  * 0.0001, 2.0);

		}

		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">

			precision mediump float;
			precision mediump int;

			uniform float time;
			uniform float sensitivity;
			uniform vec4 lightColor;
			uniform float colorContour;
			uniform float opacity;
			uniform float audio[16];

			varying vec3 vNormal;
			varying vec4 vColor;

			void main()	{
				vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));
				
				vec4 color = lightColor;//vec4( vColor );
        		color *= dot(normalize(vNormal),lightDir);

        		float audioColor = colorContour * (audio[4] + audio[5] + audio[6] * audio[7] * 3.0)  * 0.0001;
        		// color = color * audioColor;
        		// if (audioColor > 1.0) {
		    	 // color = 0.5 * sin(color * audioColor) + 0.5;
	        	// }
				// color.r += sin( vPosition.x * 10.0 + time ) * 0.5;
				color.a = opacity;
				gl_FragColor = vec4( color );
				
			}

		</script>

		

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, renderer, controls;
			var listener, audioLoader, audioArray, bufferLength, analyser, smoothVolume;
			var audioCtx, source, stream, useMicrophone, micAnalyser, micData;
			var pointLight, skyBox;

			var gui, params, detail, triangleSize, sizeCallBack, drawStyle, GeometryA, GeometryB, aSelectedGeometry, bSelectedGeometry;
			var sound, playAudio, volume, geometry, material, mouse, noiseShape, noiseGeometry;

			var colorTracker;
			var worker;

			var loader = new THREE.FontLoader();
			var font;
			var keyFrames, tween;
			var updatingCamera = false;


			

			document.getElementById("progressBar").style.visibility = "visible";
			initGui();
			gui.closed = true;
			loader.load( 'fonts/SharpSansNo1Medium_Regular.json', function ( loadedFont ) {
				font = loadedFont;
				init();
				animate();
				
			} );				

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 5, 50000 );
				camera.position.set(0, 0, 1170);
				if(window.mobileAndTabletCheck()) {
					params.camZ = 3280;
					camera.position.set(params.camX, params.camY, params.camZ);
				}
				
				scene = new THREE.Scene();

				colorTracker = new ColorTracker();

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'click', onDocumentMouseClick, false );
				mouse = new THREE.Vector2();

				// initGui();

				worker = new Worker('js/GeometryWorker.js');
				worker.addEventListener('message', workerCallBack);
				
		        //audio
		        var listener = new THREE.AudioListener();
		        camera.add( listener );
		        
		        sound = new THREE.Audio( listener );
		        sound.startTimer = -1.0;
		        sound.startTime = 0.0;
		        sound.currentTime = 0.0;
		        var audioLoader = new THREE.AudioLoader();
		        var url = 'audio/Mike Gao - Adventura 320kbps.mp3'
		        audioLoader.load( url , function( buffer ) {
					sound.setBuffer( buffer );
					sound.setLoop(true);
					sound.setVolume(0.5);
					sound.play();
					sound.autoplay = true;
					sound.startTimer = new Date().getTime() / 1000 - sound.startTime;
					params.playAudio = true;
					var progressBar = document.getElementById("progressBar"); 
					progressBar.style.display = 'none'; 
		        },
				function ( xhr ) {
					var percent = xhr.loaded / xhr.total * 100;
					console.log( percent + '% loaded' );
				    var elem = document.getElementById("bar"); 
				    elem.style.width = percent + '%'; 
				},
				function ( xhr ) {
					console.log( 'Error loading audio' );
				});
    			navigator.getUserMedia = (navigator.getUserMedia ||
              			  navigator.webkitGetUserMedia ||
              			  navigator.mozGetUserMedia ||
              			  navigator.msGetUserMedia);
				audioCtx = new (window.AudioContext || window.webkitAudioContext)();
				var source, stream;
				micAnalyser = audioCtx.createAnalyser();
				// micAnalyser.minDecibels = -90;
				// micAnalyser.maxDecibels = -10;
				// micAnalyser.smoothingTimeConstant = 0.85;
				if (navigator.getUserMedia) {
				   console.log('getUserMedia supported.');
				   navigator.getUserMedia (
				      {audio: true},
				      function(stream) {
				         source = audioCtx.createMediaStreamSource(stream);
				         source.connect(micAnalyser);
				      },
				      // Error callback
				      function(err) {
				         console.log('The following gUM error occured: ' + err);
				      });
				} else {
				   console.log('getUserMedia not supported on your browser!');
				}

		        bufferLength = 32;
		        micAnalyser.bufferLength = bufferLength;
		        micData = new Uint8Array(bufferLength);
		        analyser = new THREE.AudioAnalyser( sound, bufferLength );
		        audioArray = new Array(16);// Uint8Array(bufferLength); 
		        for(var i = 0; i < audioArray.length; i++) {
					audioArray[i] = 0.0;
				}
		        smoothVolume = 0.0;

				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {
					console.log( item, loaded, total );
				};

		        var geometry = new THREE.PlaneBufferGeometry(params.size, params.size, params.detail*2.0, params.detail*2.0);
				noiseGeometry = new THREE.BufferGeometry();
		 		noiseGeometry.addAttribute( "position", new THREE.BufferAttribute( geometry.getAttribute( "position" ).array, 3));
		 		noiseGeometry.addAttribute( "normal", new THREE.BufferAttribute( geometry.getAttribute("normal").array, 3));
		 		noiseGeometry.addAttribute( "positionB", new THREE.BufferAttribute( geometry.getAttribute( "position" ).array, 3));
		 		noiseGeometry.addAttribute( "normalB", new THREE.BufferAttribute( geometry.getAttribute("normal").array, 3));
		 		noiseGeometry.computeBoundingSphere();
		 		noiseGeometry.needsUpdate = true;

				material = new THREE.RawShaderMaterial( {

					uniforms: {
						time: { value: 1.0 },
						audio : { type: "fv1",  value: new Array(bufferLength) },
						sensitivity : { value: params.sensitivity },
						amplitude : {value: params.amplitude },
						noiseIterations : { value: params.noiseIterations },
						lightColor : { value: new THREE.Vector4(1.0, 1.0, 1.0, 1.0) },
						sinScale : { value: params.sinScale },
						scale : { value: params.scale },
						abMix : { value : params.abMix },
						colorContour : { value: params.colorContour },
						opacity : { value: params.opacity },
						triangleSize : { value: params.triangleSize },
						highFrequencyMix : {value : params.highFrequencyMix },
						mouse : {value : mouse }

					},
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
					side: THREE.DoubleSide,
					transparent: true
				} );

				//Initializes the noiseShape with aSelectedGeometry and bSelectedGeometry.
				aSelectedGeometry = "Solid Sphere";
				bSelectedGeometry = "Text";
				params.style = "Mesh";
				params.GeometryA = aSelectedGeometry;
				params.GeometryB = bSelectedGeometry;
				updateGeomAndDrawStyle("Mesh");

				keyFrames = new KeyFrames();
				initKeyFrames(keyFrames);

				pointLight = new THREE.PointLight(0xFFFFFF, 1.0);
				scene.add(pointLight);
        
				var skyBoxMat = new THREE.MeshStandardMaterial( { roughness:0.4, color: 0xFFFFFF, emissive: 0x000000, emissiveIntensity:0, side: THREE.DoubleSide } );
				var skyBoxGeom = new THREE.SphereGeometry(5500, 32, 32);
				skyBox = new THREE.Mesh(skyBoxGeom, skyBoxMat);
				scene.add(skyBox);

				renderer = new THREE.WebGLRenderer({ antialias : true });
				renderer.setClearColor( 0x101010 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.dampingFactor = 0.9;  
				controls.zoomSpeed = 0.3;
				controls.rotateSpeed = 0.3;	
				controls.maxDistance = 5000;
        
				// stats = new Stats();
				// container.appendChild( stats.dom );

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function initGui() {
				params = {
					sensitivity: 0.2,
					amplitude : 500,
					pointLightIntensity : 0.001,
					time : 0.2,
					noiseIterations : 8.0,
					highFrequencyMix : 1.0,
					audioSmoothing: 0.94,
					size : 2000,
					detail : 200,
					triangleSize : 30.0,
					playAudio : false,
					useMicrophone : false,
					scale : 0.15,
					abMix : 1.0,
					sinScale : 0.01,
					volume : 0.5,
					colorContour : 1.3, 
					opacity : 0.0,
					saturation : 1.0,
					lightness : 0.65,
					style : ['Points', 'Line', 'Mesh'],
					text : "FILAMENT",
					GeometryA : ['Plane', 'Sphere', 'Solid Sphere', 'Text'],
					GeometryB : ['Plane', 'Sphere', 'Solid Sphere', 'Text'],
					camX : 0.0,
					camY : 0.0,
					camZ : 1170.0
				};
				gui = new dat.GUI();
				var f1 = gui.addFolder('Lights');
				f1.add( params, "pointLightIntensity", 0.0, 0.5 ).listen();
				f1.add( params, "colorContour", 0.1, 20.0 ).listen();
				f1.add( params, "opacity", 0.0, 1.0 ).listen();
				f1.add( params, "saturation", 0.0, 1.0 ).listen();
				f1.add( params, "lightness", 0.0, 1.0 ).listen();
				var f2 = gui.addFolder('Noise');
				f2.add( params, "time", -4.0, 8.0 ).listen();
				var f3 = gui.addFolder('Geometry');
				if( window.mobileAndTabletCheck() ) {
					// params['detail'] = 20;
					// params['noiseIterations'] = 8.0;
					// params['sensitivity'] = 0.2;
					f2.add( params, "sensitivity", 0.2, 10.0 );
					f2.add( params, "amplitude", 1.0, 500.0 ).listen();
					f2.add( params, "noiseIterations", 1.0, 6.0 );
					detail = f3.add( params, "detail", 1, 300 );
				} else {
					
					f2.add( params, "sensitivity", 0.2, 10.0 );
					f2.add( params, "amplitude", 1.0, 500.0 ).listen();
					f2.add( params, "noiseIterations", 1.0, 8.0 );
					detail = f3.add( params, "detail", 1, 300 );
				}
				f2.add( params, "sinScale", 0.0001, 1.8 ).listen();
				f2.add( params, "scale", 0.01, 0.6 );
				
				f2.add( params, "highFrequencyMix", 0.01, 1.0 ).listen();
				sizeCallBack = f3.add( params, "size", 1, 3000 ).listen();
				
				triangleSize = f3.add( params, "triangleSize", 1, 32 ).listen();
				drawStyle = f3.add( params, "style", params.style).listen();

				GeometryA = f3.add( params, "GeometryA", params.GeometryA).listen();
				GeometryB = f3.add( params, "GeometryB", params.GeometryB).listen();
				f3.add( params, "abMix", 0.0, 1.0 ).listen();
				f3.add( params, "text", params.text );
				var f4 = gui.addFolder('Audio');
				f4.add( params, "audioSmoothing", 0.0, 0.9).listen();
				volume = f4.add( params, "volume", 0.0, 0.5).listen();
				playAudio = f4.add( params, "playAudio").listen();
				useMicrophone = f4.add( params, "useMicrophone").listen();
				f2.open();
				f3.open();
				gui.remember(params);
			}

			function initKeyFrames(keyFrames) {
				var keyFrame = new KeyFrame({opacity: 1.0}, function() {}, TWEEN.Easing.Quadratic.InOut, 4000, 0.0);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({sinScale: 0.02}, function() {}, TWEEN.Easing.Quadratic.Out, 80, 7.0);
				keyFrames.push(keyFrame);
				keyFrame = new KeyFrame({
					abMix: 0.0,
					highFrequencyMix : 0.8,
					amplitude : 100,
					time : -2.0, 
					sinScale : 0.07
				}, function() {
				}, TWEEN.Easing.Quadratic.Out, 7000, 7.7);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({}, function() {
					asyncUpdateGeometry("B", "Plane");
					bSelectedGeometry = "Plane";
				}, null, null, 13.6);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({abMix: 0.7, time: 4.0}, function() {}, TWEEN.Easing.Quadratic.InOut, 800, 14.6);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({
					style: "Line"
				}, function() {
					updateGeomAndDrawStyle("Line");
				}, null, null, 15.52);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({sinScale: 0.9, amplitude : 450}, function() {}, TWEEN.Easing.Quadratic.Out, 100, 19.55);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({time: -4.0, abMix: 1.0}, function() {}, TWEEN.Easing.Quadratic.Out, 1000, 27);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({time: 2.0}, function() {}, TWEEN.Easing.Quadratic.Out, 1000, 30);
				keyFrames.push(keyFrame);

				var keyFrame = new KeyFrame({camZ: 3000,
											abMix: 0.0
											}, 
											function() { updatingCamera = true; }, 
											TWEEN.Easing.Quadratic.InOut, 10000, 33.0, 
											function(){ updatingCamera = false; });
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({}, function() {
					asyncUpdateGeometry("B", "Sphere");
					bSelectedGeometry = "Sphere";
				}, null, null, 40);
				keyFrames.push(keyFrame);		

				keyFrame = new KeyFrame({abMix: 1.0, sensitivity : 2.0}, function() {}, TWEEN.Easing.Quadratic.InOut, 3000, 45.6);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({pointLightIntensity: 0.2}, function() {}, TWEEN.Easing.Quadratic.InOut, 2000, 49.0);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({camZ: 400}, function() { updatingCamera = true; }, 
											TWEEN.Easing.Quadratic.InOut, 5000, 50.0, 
											function(){ updatingCamera = false; });
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({camY: -550}, function() { updatingCamera = true; }, 
											TWEEN.Easing.Quadratic.InOut, 5000, 55.0, 
											function(){ updatingCamera = false; });
				keyFrames.push(keyFrame);				

				keyFrame = new KeyFrame({}, function() {
					asyncUpdateGeometry("A", "Solid Sphere");
					aSelectedGeometry = "Solid Sphere";
				}, null, null, 56.2);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({pointLightIntensity: 0.0}, function() {}, TWEEN.Easing.Quadratic.InOut, 1000, 60.0);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({
					style: "Mesh"
				}, function() {
					updateGeomAndDrawStyle("Mesh");
				}, null, null, 62);
				keyFrames.push(keyFrame);
				keyFrame = new KeyFrame({time: 2.5, sinScale :0.85 }, function() {}, TWEEN.Easing.Quadratic.InOut, 3000, 65.9);
				keyFrames.push(keyFrame);
				
				keyFrame = new KeyFrame({abMix: 0.999, amplitude : 300, time: -2.5}, function() {}, TWEEN.Easing.Quadratic.InOut, 1000, 73.84);
				keyFrames.push(keyFrame);
				// keyFrame = new KeyFrame({abMix: 0.999, amplitude : 300, time: -2.5}, function() {}, TWEEN.Easing.Quadratic.InOut, 3000, 69.0);
				// keyFrames.push(keyFrame);
				keyFrame = new KeyFrame({time: 0.0}, function() {}, TWEEN.Easing.Quadratic.InOut, 1000, 76.0);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({abMix: 0.0, amplitude : 400, sensitivity : 0.8, highFrequencyMix : 0.7, camZ: 1700, time: -1.5}, function() {updatingCamera = true;}, TWEEN.Easing.Quadratic.InOut, 3000, 77.5, function() {updatingCamera=false;});
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({opacity : 0.0}, function() {}, TWEEN.Easing.Quadratic.InOut, 500, 92.2);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({
					style: "Points"
				}, function() {
					updateGeomAndDrawStyle("Points");
				}, null, null, 93.0);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({opacity : 1.0}, function() {}, TWEEN.Easing.Quadratic.InOut, 500, 93.1);
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({camX: 0.0, camZ: 625.0, time: -4.0}, function() {updatingCamera = true;}, TWEEN.Easing.Quadratic.InOut, 10000, 94.0, function() {updatingCamera=false;});
				keyFrames.push(keyFrame);

				keyFrame = new KeyFrame({}, function() {}, null, null, 125.0, function() {gui.closed = false;});
				keyFrames.push(keyFrame);

			}

			function workerCallBack(msg) {
				updateGeometry(msg.data[0], msg.data[1]);
			}

			//TODO: Refactor into geometry morphing class
			function updateGeometry (geomToUpdate, geom) {

				//conver the geom into buffer because functions are stripped when pased through the web worker
				var geo = new THREE.BufferGeometry();
				geo.addAttribute('position', geom.attributes.position);
				geo.addAttribute('normal', geom.attributes.normal);
				geo.computeBoundingSphere();

				var newGeomCount = geo.getAttribute("position").count * 3;
				var existingGeomCount;

				if (geomToUpdate === "A") {
					existingGeomCount = noiseGeometry.getAttribute( "positionB" ).count * 3;
					var maxCount = Math.max(existingGeomCount, newGeomCount);
					noiseGeometry.removeAttribute( "position" );
					noiseGeometry.removeAttribute( "normal" );
					var buffPA = new Float32Array( maxCount );
					var pArr = geo.getAttribute("position").array;
					for(var i = 0; i < newGeomCount; i++) {
						buffPA[i] = pArr[i];
					}
					noiseGeometry.addAttribute( "position", new THREE.BufferAttribute( buffPA, 3));

					var buffNA = new Float32Array( maxCount );
					var nArr = geo.getAttribute("normal").array;
					for(var i = 0; i < newGeomCount; i++) {
						buffNA[i] = nArr[i];
					}
					noiseGeometry.addAttribute( "normal", new THREE.BufferAttribute( buffNA, 3));

					if(existingGeomCount < newGeomCount) {
						var buffPB = new Float32Array( maxCount );
						var pBrr = noiseGeometry.getAttribute("positionB").array;
						for(var i = 0; i < newGeomCount; i++) {
							buffPB[i] = pBrr[i];
						}
						var buffNB = new Float32Array( maxCount );
						var nBrr = noiseGeometry.getAttribute("normalB").array;
						for(var i = 0; i < newGeomCount; i++) {
							buffNB[i] = nBrr[i];
						}
						noiseGeometry.removeAttribute( "positionB" );
						noiseGeometry.removeAttribute( "normalB" );
						noiseGeometry.addAttribute( "positionB", new THREE.BufferAttribute( buffPB, 3));
						noiseGeometry.addAttribute( "normalB", new THREE.BufferAttribute( buffNB, 3));
					}
					
				} else {
					existingGeomCount = noiseGeometry.getAttribute( "position" ).count * 3;
					var maxCount = Math.max(existingGeomCount, newGeomCount);
					noiseGeometry.removeAttribute( "positionB" );
					noiseGeometry.removeAttribute( "normalB" );
					var buffPB = new Float32Array( maxCount );
					var pBrr = geo.getAttribute("position").array;
					for(var i = 0; i < newGeomCount; i++) {
						buffPB[i] = pBrr[i];
					}
					noiseGeometry.addAttribute( "positionB", new THREE.BufferAttribute( buffPB, 3));

					var buffNB = new Float32Array( maxCount );
					var nBrr = geo.getAttribute("normal").array;
					for(var i = 0; i < newGeomCount; i++) {
						buffNB[i] = nBrr[i];
					}
					noiseGeometry.addAttribute( "normal", new THREE.BufferAttribute( buffNB, 3));

					if(existingGeomCount < newGeomCount) {
						var buffPA = new Float32Array( maxCount );
						var pArr = noiseGeometry.getAttribute("position").array;
						for(var i = 0; i < newGeomCount; i++) {
							buffPA[i] = pArr[i];
						}
						var buffNA = new Float32Array( maxCount );
						var nArr = noiseGeometry.getAttribute("normal").array;
						for(var i = 0; i < newGeomCount; i++) {
							buffNA[i] = nArr[i];
						}
						noiseGeometry.removeAttribute( "position" );
						noiseGeometry.removeAttribute( "normal" );
						noiseGeometry.addAttribute( "position", new THREE.BufferAttribute( buffPA, 3));
						noiseGeometry.addAttribute( "normal", new THREE.BufferAttribute( buffNA, 3));
					}
				}
				noiseShape.geometry.needsUpdate = true;
			}

			function asyncUpdateGeometry(geomToUpdate, selectedGeometry) {
				if ( selectedGeometry == "Plane" ) {
					worker.postMessage([geomToUpdate, selectedGeometry, params.size, params.detail]);
				} else if( selectedGeometry == "Sphere" ) {
					worker.postMessage([geomToUpdate, selectedGeometry, params.size, params.detail]);
				} else if( selectedGeometry == "Solid Sphere" ) {
					worker.postMessage([geomToUpdate, selectedGeometry, params.size, params.detail, params.triangleSize]);
				} else if ( selectedGeometry == "Text" ) {
					worker.postMessage([geomToUpdate, selectedGeometry, params.size, params.detail, font, params.text]);
				}  
			}

			GeometryA.onChange( function(value) {
				console.log(value);
				if (value !== aSelectedGeometry) {
					asyncUpdateGeometry("A", value);
				}
				aSelectedGeometry = value;
			});

			GeometryB.onChange( function (value) {
				if (value !== bSelectedGeometry) {
					asyncUpdateGeometry("B", value);
				}
				bSelectedGeometry = value;
			});

			function updateGeomAndDrawStyle(drawStyle){
				asyncUpdateGeometry("A", aSelectedGeometry);
				asyncUpdateGeometry("B", bSelectedGeometry);
				scene.remove(noiseShape);
				if(drawStyle == "Points") {
					noiseShape = new THREE.Points( noiseGeometry, material );
					noiseShape.lights = true;
				} else if(drawStyle == "Line") {
					noiseShape = new THREE.LineSegments( noiseGeometry, material );
				} else {
					noiseShape = new THREE.Mesh( noiseGeometry, material );
				}
				scene.add(noiseShape);
			}

			drawStyle.onChange(function(value) {
				updateGeomAndDrawStyle(value);
			});

			//Dat.gui callback methods
			detail.onChange(function(value) {
				asyncUpdateGeometry("A", aSelectedGeometry);
				asyncUpdateGeometry("B", bSelectedGeometry);
			});

			sizeCallBack.onChange(function(value) {
				asyncUpdateGeometry("A", aSelectedGeometry);
				asyncUpdateGeometry("B", bSelectedGeometry);
			});

			triangleSize.onChange(function(value) {
				asyncUpdateGeometry("A", aSelectedGeometry);
				asyncUpdateGeometry("B", bSelectedGeometry);
			});
			
			volume.onChange(function(value) {
				sound.setVolume(value);
			});

			playAudio.onChange(function(shouldPlay) {
				if (shouldPlay) {
					sound.play();
					analyser = new THREE.AudioAnalyser( sound, bufferLength );
				} else {
					sound.pause();
				}
				
			});

			useMicrophone.onChange(function(shouldUseMic) {
				if(shouldUseMic) {
					sound.pause();
					params.playAudio = false;
				} else {

				}
			});

			function onDocumentMouseMove(event) {
				mouse.x = ( event.clientX / window.innerWidth );
				mouse.y = ( event.clientY / window.innerHeight );
			}

			function onDocumentMouseClick(event) {
				console.log(sound.currentTime);
				console.log(camera.position);
			}			

			function onWindowResize( event ) {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );
				render();
				// stats.update();

			}

			function render() {

				var time = performance.now();
				TWEEN.update(time);
				
				if (sound.startTimer != -1) {
					sound.currentTime = new Date().getTime() / 1000 - sound.startTimer;
				}
				keyFrames.update(sound.currentTime, params);

				colorTracker.update();

				controls.update();
				var smoothA = Math.sqrt(params.audioSmoothing);
				var smoothB = 1 - smoothA;
		        smoothVolume = smoothB * analyser.getAverageFrequency() * 0.01 + smoothA * smoothVolume;
		        pointLight.intensity = smoothVolume * params.pointLightIntensity;

		        var freshAudio, color;
		        var averageFrequency;
		        if(params.useMicrophone) {
		        	micAnalyser.getByteFrequencyData(micData);
		        	freshAudio = new Array(micData.length);
		        	var sum = 0;
		        	for(var i = 0; i < freshAudio.length; i++) {
		        		freshAudio[i] = micData[i];
		        		sum += freshAudio[i];
		        	}
		        	averageFrequency = sum / freshAudio.length / 2.0;
		        	console.log(averageFrequency);
		        	color = colorTracker.getColor(averageFrequency, 100);
		        } else {
		        	freshAudio = analyser.getFrequencyData();
		        	color = colorTracker.getColor(analyser.getAverageFrequency(), 100);
		        }

		        var index = 0;
				for(var i = 0; i < freshAudio.length; i+=2) {
					var averagedAudio = (freshAudio[i] + 
										freshAudio[i + 1]) / 2.0; 
										//freshAudio[i + 2] +
										//freshAudio[i + 3]) / 4.0;
					//audio smoothing
					audioArray[index] = smoothA * averagedAudio + smoothB * freshAudio[index]; 
					index +=1;
				}

				var hsl = color.getHSL();
				color.setHSL(hsl.h, params.saturation, params.lightness);
				if(updatingCamera) {
					camera.position.set(params.camX, params.camY, params.camZ);
				}

				var objUniforms = noiseShape.material.uniforms;
				objUniforms.audio.value = audioArray;
				objUniforms.time.value += (time * 0.000005) * 0.7 + smoothVolume * smoothVolume * params.time;
				objUniforms.sensitivity.value = params.sensitivity;
				objUniforms.amplitude.value = params.amplitude;
				objUniforms.noiseIterations.value = params.noiseIterations;
				objUniforms.scale.value = 0.01 * params.scale;
				objUniforms.abMix.value = params.abMix;
				objUniforms.sinScale.value = params.sinScale;
				objUniforms.colorContour.value = params.colorContour;
				objUniforms.opacity.value = params.opacity;
				objUniforms.triangleSize.value = params.triangleSize;
				objUniforms.highFrequencyMix.value = params.highFrequencyMix;
				objUniforms.mouse.value = mouse;
				objUniforms.lightColor.value = new THREE.Vector4(color.r, color.g, color.b, color.a);

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
